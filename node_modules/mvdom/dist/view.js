"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const dom_1 = require("./dom");
const utils_1 = require("./utils");
let viewIdSeq = 0;
const hookStageNames = ['willCreate', 'didCreate', 'willInit', 'didInit', 'willDisplay', 'didDisplay', 'willPostDisplay', 'didPostDisplay', 'willRemove', 'didRemove'];
const hooks = new Map(hookStageNames.map(name => [name, []]));
function hook(hookStage, cb) {
    hooks.get(hookStage).push(cb);
}
exports.hook = hook;
const defaultConfig = {
    append: "last"
};
function display(viewInstance, refEl, config_or_append) {
    const self = this;
    const view = viewInstance;
    const config = (typeof config_or_append === "string") ? { append: config_or_append } : Object.assign({}, defaultConfig, config_or_append);
    view.config = config;
    if (view.name == null && view.constructor) {
        view.name = view.constructor.name;
    }
    view.id = viewIdSeq++;
    return doCreate(view, config)
        .then(function () {
        return doInit(view, config);
    })
        .then(function () {
        return doDisplay.call(self, view, refEl, config);
    })
        .then(function () {
        return doPostDisplay(view, config);
    });
}
exports.display = display;
function empty(els) {
    for (const el of utils_1.asNodeArray(els)) {
        removeEl(el, true);
    }
}
exports.empty = empty;
function remove(els) {
    for (const el of utils_1.asNodeArray(els)) {
        removeEl(el);
    }
}
exports.remove = remove;
function removeEl(el, childrenOnly) {
    childrenOnly = (childrenOnly === true);
    const childrenViewEls = dom_1.all(el, ".d-view");
    const viewEls = childrenViewEls.reverse();
    viewEls.forEach(function (viewEl) {
        if (viewEl._view) {
            doRemove(viewEl._view);
        }
        else {
            console.log("MVDOM - WARNING - the following dom element should have a ._view property but it is not? (safe ignore)", viewEl);
        }
    });
    if (childrenOnly) {
        while (el.lastChild) {
            el.removeChild(el.lastChild);
        }
    }
    else {
        if (el._view) {
            doRemove(el._view);
        }
        else {
            if (el.parentNode) {
                el.parentNode.removeChild(el);
            }
        }
    }
}
function doCreate(view, config) {
    performHook("willCreate", view);
    const p = Promise.resolve(view.create(config));
    return p.then(function (html_or_node) {
        let node = (typeof html_or_node === "string") ? dom_1.frag(html_or_node) : html_or_node;
        if (node == null) {
            throw new Error(`MVDOM - cannot create view ${view.constructor.name} because doCfreate did not return a valid now`);
        }
        if (node.nodeType === 11) {
            if (node.childNodes.length > 1) {
                console.log("mvdom - WARNING - view HTML for view", view, "has multiple childNodes, but should have only one. Fallback by taking the first one, but check code.");
            }
            node = node.firstChild;
        }
        if (node.nodeType !== 1) {
            throw new Error("el for view " + view.name + " is node of type Element. " + node);
        }
        const viewEl = node;
        view.el = viewEl;
        view.el.classList.add("d-view");
        view.el._view = view;
        performHook("didCreate", view);
    });
}
function doInit(view, config) {
    performHook("willInit", view);
    let res;
    if (view.init) {
        res = view.init(config);
    }
    return Promise.resolve(res).then(function () {
        performHook("didInit", view);
    });
}
function doDisplay(view, refEl, config) {
    if (typeof refEl === "string") {
        refEl = dom_1.first(refEl);
    }
    performHook("willDisplay", view);
    try {
        dom_1.append.call(this, refEl, view.el, config.append);
    }
    catch (ex) {
        throw new Error("mvdom ERROR - Cannot add view.el " + view.el + " to refEl " + refEl + ". Cause: " + ex.toString());
    }
    performHook("didDisplay", view);
    return new Promise(function (resolve, fail) {
        setTimeout(function () {
            resolve();
        }, 0);
    });
}
function doPostDisplay(view, config) {
    performHook("willPostDisplay", view);
    let result;
    if (view.postDisplay) {
        result = view.postDisplay(config);
    }
    return Promise.resolve(result).then(function () {
        return view;
    });
}
function doRemove(view) {
    performHook("willRemove", view);
    let parentEl;
    if (view.el && view.el.parentNode) {
        parentEl = view.el.parentNode;
        view.el.parentNode.removeChild(view.el);
    }
    if (view.destroy) {
        view.destroy({ parentEl: parentEl });
    }
    performHook("didRemove", view);
}
function performHook(name, view) {
    const hookFuns = hooks.get(name);
    let i = 0, l = hookFuns.length, fun;
    for (; i < l; i++) {
        fun = hookFuns[i];
        fun(view);
    }
}
//# sourceMappingURL=view.js.map