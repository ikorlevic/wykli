"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("./utils");
function first(el_or_selector, selector) {
    if (!selector && typeof el_or_selector !== "string") {
        const el = el_or_selector;
        const firstElementChild = el.firstElementChild;
        if (!firstElementChild && el.firstChild) {
            if (el.firstChild.nodeType === 1) {
                return el.firstChild;
            }
            else {
                return next(el.firstChild);
            }
        }
        return firstElementChild;
    }
    else {
        return _execQuerySelector(false, el_or_selector, selector);
    }
}
exports.first = first;
function all(el, selector) {
    const nodeList = _execQuerySelector(true, el, selector);
    return (nodeList != null) ? utils_1.asNodeArray(nodeList) : [];
}
exports.all = all;
function next(el, selector) {
    return _sibling(true, el, selector);
}
exports.next = next;
function prev(el, selector) {
    return _sibling(false, el, selector);
}
exports.prev = prev;
function closest(el, selector) {
    return (el) ? el.closest(selector) : null;
}
exports.closest = closest;
function append(refEl, newEl, position) {
    let parentEl;
    let nextSibling = null;
    position = (position) ? position : "last";
    if (position === "last" || position === "first" || position === "empty") {
        parentEl = refEl;
    }
    else if (position === "before" || position === "after") {
        parentEl = refEl.parentNode;
        if (!parentEl) {
            throw new Error("mvdom ERROR - The referenceElement " + refEl + " does not have a parentNode. Cannot insert " + position);
        }
    }
    if (position === "first") {
        nextSibling = first(refEl);
    }
    else if (position === "before") {
        nextSibling = refEl;
    }
    else if (position === "after") {
        nextSibling = next(refEl);
    }
    if (nextSibling) {
        parentEl.insertBefore(newEl, nextSibling);
    }
    else {
        if (position === "empty") {
            this.empty(refEl);
        }
        parentEl.appendChild(newEl);
    }
    return newEl;
}
exports.append = append;
function frag(html) {
    html = (html) ? html.trim() : null;
    const template = document.createElement("template");
    if (html) {
        template.innerHTML = html;
    }
    return template.content;
}
exports.frag = frag;
function _sibling(next, el, selector) {
    const sibling = (next) ? 'nextSibling' : 'previousSibling';
    let tmpEl = (el) ? el[sibling] : null;
    while (tmpEl != null && tmpEl !== document) {
        if (tmpEl.nodeType === 1 && (!selector || tmpEl.matches(selector))) {
            return tmpEl;
        }
        tmpEl = tmpEl[sibling];
    }
    return null;
}
function _execQuerySelector(all, elOrSelector, selector) {
    let el = null;
    if (elOrSelector == null) {
        return null;
    }
    if (typeof selector === "undefined") {
        selector = elOrSelector;
        el = document;
    }
    else {
        el = elOrSelector;
    }
    return (all) ? el.querySelectorAll(selector) : el.querySelector(selector);
}
//# sourceMappingURL=dom.js.map