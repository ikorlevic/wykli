"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("./utils");
function on(els, types, arg1, arg2, arg3) {
    let opts;
    let listener;
    let selector;
    if (arg1 instanceof Function) {
        listener = arg1;
        opts = arg2;
    }
    else {
        selector = arg1;
        listener = arg2;
        opts = arg3;
    }
    let eventOptions;
    if (opts && (opts.passive != null || opts.capture != null)) {
        eventOptions = {};
        if (opts.passive != null) {
            eventOptions.passive = opts.passive;
        }
        if (opts.capture != null) {
            eventOptions.capture = opts.capture;
        }
    }
    if (els == null) {
        return;
    }
    const typeArray = utils_1.splitAndTrim(types, ",");
    typeArray.forEach(function (type) {
        const typeSelectorKey = buildTypeSelectorKey(type, selector);
        utils_1.asNodeArray(els).forEach(function (el) {
            let _listener = listener;
            if (selector) {
                _listener = function (evt) {
                    let tgt = null;
                    const target = evt.target;
                    const currentTarget = evt.currentTarget;
                    const ctx = (opts) ? opts.ctx : null;
                    if (target && target.matches(selector)) {
                        evt.selectTarget = target;
                        listener.call(ctx, evt);
                    }
                    else {
                        tgt = evt.target.parentNode;
                        while (tgt !== null && tgt !== currentTarget && tgt !== document) {
                            if (tgt.matches(selector)) {
                                evt.selectTarget = tgt;
                                listener.call(ctx, evt);
                                tgt = null;
                                break;
                            }
                            tgt = tgt.parentNode;
                        }
                    }
                };
            }
            else if (opts && opts.ctx) {
                _listener = function (evt) {
                    listener.call(opts.ctx, evt);
                };
            }
            const listenerRef = {
                type: type,
                listener: listener,
                _listener: _listener,
            };
            if (selector) {
                listenerRef.selector = selector;
            }
            if (opts && opts.ns) {
                listenerRef.ns = opts.ns;
                let listenerRefSetByNs = utils_1.ensureMap(el, "listenerRefsByNs");
                let listenerRefSet = utils_1.ensureSet(listenerRefSetByNs, opts.ns);
                listenerRefSet.add(listenerRef);
            }
            let listenerDic = utils_1.ensureMap(el, "listenerDic");
            let listenerRefByListener = utils_1.ensureMap(listenerDic, typeSelectorKey);
            listenerRefByListener.set(listener, listenerRef);
            el.addEventListener(type, _listener, eventOptions);
        });
    });
}
exports.on = on;
function off(els, type_or_opts, selector_or_listener, maybe_listener) {
    if (els == null) {
        return;
    }
    const opts = (type_or_opts && type_or_opts.ns) ? type_or_opts : null;
    const type = (opts === null) ? type_or_opts : null;
    let selector = null;
    let listener;
    const tof = typeof selector_or_listener;
    if (tof === 'function') {
        selector = null;
        listener = selector_or_listener;
    }
    else if (tof === 'string') {
        selector = selector_or_listener;
        listener = maybe_listener;
    }
    if (opts && opts.ns) {
        const ns = opts.ns;
        utils_1.asNodeArray(els).forEach(function (el) {
            const listenerDic = el.listenerDic;
            const listenerRefsByNs = el.listenerRefsByNs;
            let listenerRefSet;
            if (listenerRefsByNs && listenerDic) {
                listenerRefSet = listenerRefsByNs.get(ns);
                if (listenerRefSet) {
                    listenerRefSet.forEach(function (listenerRef) {
                        el.removeEventListener(listenerRef.type, listenerRef._listener);
                        const typeSelectorKey = buildTypeSelectorKey(listenerRef.type, listenerRef.selector);
                        const listenerRefMapByListener = listenerDic.get(typeSelectorKey);
                        if (listenerRefMapByListener && listenerRefMapByListener.has(listenerRef.listener)) {
                            listenerRefMapByListener.delete(listenerRef.listener);
                        }
                        else {
                            console.log("INTERNAL ERROR should have a listener in el.listenerDic for " + typeSelectorKey);
                        }
                    });
                    listenerRefsByNs.delete(ns);
                }
            }
        });
        return;
    }
    const typeSelectorKey = buildTypeSelectorKey(type, selector);
    utils_1.asNodeArray(els).forEach(function (el) {
        const listenerRefMapByListener = (el.listenerDic) ? el.listenerDic.get(typeSelectorKey) : null;
        if (!listenerRefMapByListener) {
            console.log("WARNING - Cannot do .off() since this type-selector '" + typeSelectorKey +
                "' event was not bound with .on(). We will add support for this later.");
            return;
        }
        if (typeof listener === "undefined" && type) {
            listenerRefMapByListener.forEach(function (listenerRef) {
                el.removeEventListener(type, listenerRef._listener);
            });
            el.listenerDic.delete(typeSelectorKey);
        }
        else {
            const listenerRef = (listener) ? listenerRefMapByListener.get(listener) : null;
            if (!listenerRef) {
                console.log("WARNING - Cannot do .off() since no listenerRef for " + typeSelectorKey +
                    " and function \n" + listener + "\n were found. Probably was not registered via on()");
                return;
            }
            el.removeEventListener(type, listenerRef._listener);
            listenerRefMapByListener.delete(listener);
        }
    });
}
exports.off = off;
const customDefaultProps = {
    bubbles: true,
    cancelable: true
};
function trigger(els, type, info) {
    if (els == null) {
        return;
    }
    utils_1.asNodeArray(els).forEach(function (el) {
        const evt = new CustomEvent(type, Object.assign({}, customDefaultProps, { selectTarget: el }, info));
        el.dispatchEvent(evt);
    });
}
exports.trigger = trigger;
function bindDOMEvents(el, eventDics, opts) {
    eventDics = (eventDics instanceof Array) ? eventDics : [eventDics];
    for (const eventDic of eventDics) {
        for (const selector in eventDic) {
            bindDOMEvent(el, selector, eventDic[selector], opts);
        }
    }
}
exports.bindDOMEvents = bindDOMEvents;
function bindDOMEvent(el, typeAndSelector, fn, opts) {
    let selectorSplitted = typeAndSelector.trim().split(";");
    let type = selectorSplitted[0].trim();
    let selector = null;
    if (selectorSplitted.length > 1) {
        selector = selectorSplitted[1].trim();
    }
    on(el, type, selector, fn, opts);
}
exports.bindDOMEvent = bindDOMEvent;
function buildTypeSelectorKey(type, selector) {
    return (selector) ? (type + "--" + selector) : type;
}
//# sourceMappingURL=event.js.map